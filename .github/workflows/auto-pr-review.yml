# ======================================================================================
# Workflow: Auto PR Review
# ======================================================================================
# Usage:
# - Runs automatically when a Pull Request is opened or marked ready for review.
# - Analyzes the diff of the PR.
#
# Setup:
# - Ensure WARP_API_KEY is set in Repository Secrets.
# - The Agent needs read access to contents and write access to pull-requests.
#
# Expected Output:
# - Inline comments on the PR diff highlighting potential bugs, security issues, or style improvements.
# - A general summary comment if applicable.
#
# When to use:
# - Use this to get immediate feedback on code changes before human review.
# ======================================================================================
name: Auto PR Review

on:
  pull_request:
    types: [opened, ready_for_review]

jobs:
  review_pr:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Checkout PR
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh pr checkout ${{ github.event.pull_request.number }}
          git fetch origin ${{ github.event.pull_request.base.ref }}
          # Diff only the changes introduced in this PR, relative to the PR's base commit
          # Add line numbers to each line: OLD_LINE NEW_LINE for context, OLD_LINE for deletions, NEW_LINE for additions
          git diff ${{ github.event.pull_request.base.sha }}...HEAD | awk '
            /^diff --git/ { print; next }
            /^index / { print; next }
            /^---/ { print; next }
            /^\+\+\+/ { print; next }
            /^@@/ {
              # Parse hunk header: @@ -old_start,old_count +new_start,new_count @@
              split($2, old_parts, ",")
              split($3, new_parts, ",")
              old_line = -old_parts[1]
              new_line = substr(new_parts[1], 2)
              print
              next
            }
            /^-/ { printf "[OLD:%d]%s\n", old_line++, $0; next }
            /^\+/ { printf "[NEW:%d]%s\n", new_line++, $0; next }
            { printf "[OLD:%d,NEW:%d]%s\n", old_line++, new_line++, $0 }
          ' > pr_diff.txt

      - name: Construct Review Prompt
        id: prompt
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;

            // Fetch PR details
            const { data: pr } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber,
            });

            // Read the diff
            const diffContent = fs.readFileSync('pr_diff.txt', 'utf8');

            const prompt = `You are an expert software engineer and code reviewer.
            Your task is to provide a comprehensive code review focused on the changes introduced in Pull Request #${prNumber}.

            ## System Context

            - Working directory is PR branch.
            - You have access to the full source code, but you should primarily analyze and comment on the diff below
            - **Restrict feedback to code modified in this PR and its immediate context**. Do not comment on untouched files or lines (GitHub will reject these comments). If you must mention issues in untouched code, add them to the summary instead

            ## PR Context

            - **Title**: ${pr.title}
            - **Description**: ${pr.body || 'No description provided.'}

            ## Code Changes (Diff)

            Each line in the diff is annotated with line numbers:
            - \`[OLD:n]\` prefix = deleted line at line n in old file (use side: "LEFT")
            - \`[NEW:n]\` prefix = added line at line n in new file (use side: "RIGHT") 
            - \`[OLD:n,NEW:m]\` prefix = unchanged context line (use side: "RIGHT" with line m)

            \`\`\`
            ${diffContent}
            \`\`\`

            ## Review Instructions

            ### 1. Severity Labels (Required)

            Every comment body MUST begin with one of:
            - \`üö® [CRITICAL]\` ‚Äî Bugs, security issues, crashes, data loss
            - \`‚ö†Ô∏è [IMPORTANT]\` ‚Äî Error handling gaps, edge cases, logic issues
            - \`üí° [SUGGESTION]\` ‚Äî Improvements, better patterns, optimizations
            - \`üßπ [NIT]\` ‚Äî Style, naming, cleanup (ONLY if providing a suggestion block)

            ### 2. What to Look For

            - **Bugs**: Logic errors, potential crashes, unhandled edge cases
            - **Security**: Vulnerabilities, injection risks, auth issues
            - **Error handling**: Swallowed errors, missing validation
            - **Performance**: Significant issues only (not micro-optimizations)
            - **Style/Nits**: Only comment if you can provide a concrete fix via suggestion block

            ### 3. Comment Format

            - **Be concise**: Use bullets, fragments, markdown‚Äînot full sentences. Prioritize readability and scannability. Complex issues can be more verbose if absolutely necessary.
            - **Be direct**: No compliments or hedging in comments (save praise for summary)
            - **Be definitive**: Say "This will fail when X" not "This might fail"
            - **Be actionable**: Provide a recommendation, not just options

            ### 4. Suggestion Blocks

            When proposing code changes, use suggestion blocks:

            \`\`\`suggestion
            
            \`\`\`

            **Suggestion rules:**
            - Match the **exact indentation** of the original file
            - Include **only the replacement code**, no extra context lines
            - For multi-line suggestions, set \`start_line\` to first line, \`line\` to last line

            ### 5. JSON Output Schema

            \`\`\`json
            {
              "summary": "## Overview\\nThis PR adds user authentication... (high-level description)\\n\\n## Concerns\\n- Error handling in db layer needs attention\\n- (any issues in untouched code)\\n\\n## Verdict\\nFound: 1 critical, 2 important, 3 suggestions\\n\\n**Request changes** ‚Äî critical bug in error handling must be addressed",
              "comments": [
                {
                  "path": "path/to/file",
                  "line": 42,
                  "side": "RIGHT",
                  "start_line": 40,
                  "body": "[SEVERITY] Brief description\\n\\n\\\`\\\`\\\`suggestion\\ncode fix\\n\\\`\\\`\\\`"
                }
              ]
            }
            \`\`\`

            - \`line\`: Line number in new file (RIGHT) or old file (LEFT) 
            - \`start_line\`: (optional) First line of range; \`line\` should be last line
            - \`side\`: "RIGHT" for additions/context, "LEFT" for deletions
            - \`path\`: Relative path from repository root

            **Comment span rules:**
            - Keep spans **‚â§10 lines** (i.e., \`line - start_line <= 10\`)‚Äîsmaller spans are easier to review
            - Prefer single-line comments; use multi-line only when necessary

            ### 6. Summary Requirements

            The \`summary\` field must include:
            - High-level code summary, overview, architectural concerns, final recommendation
            - Issue counts: "Found: X critical, Y important, Z suggestions"
            - Any concerns about untouched code that couldn't be commented inline
            - Final recommendation: "Approve", "Approve with nits", or "Request changes"

            ### 7. Final Step

            - Create \`review.json\` with your drafted content
            - Validate JSON with \`jq\`. If this fails, update the \`review.json\` file with the correct JSON. Do not attempt to use \`rm\` 
            - Ensure line numbers are correct and match the diff

            ---

            ## Examples

            ### Example 1: Critical Bug

            **Diff snippet:**
            \`\`\`
            [NEW:45] results, err := db.Query(userQuery)
            [NEW:46] if err != nil {
            [NEW:47] return nil
            [NEW:48] }
            \`\`\`

            **Comment:**
            \`\`\`json
            {
              "path": "api/handlers/users.go",
              "line": 47,
              "side": "RIGHT",
              "body": "üö® [CRITICAL] Error returned to caller is lost‚Äîwill mask DB failures and return nil slice indistinguishable from empty result\\n\\n\\\`\\\`\\\`suggestion\\n return nil, err\\n\\\`\\\`\\\`"
            }
            \`\`\`

            ### Example 2: Nit with Suggestion

            **Diff snippet:**
            \`\`\`
            [NEW:28] use std::collections::{HashMap, BTreeMap, HashSet};
            [NEW:29] use std::sync::Arc;
            [NEW:30] use crate::models::User;
            [NEW:31] use crate::utils::validate;
            \`\`\`

            **Comment:**
            \`\`\`json
            {
              "path": "src/service.rs",
              "line": 28,
              "side": "RIGHT",
              "body": "üßπ [NIT] \\\`BTreeMap\\\` unused in this module\\n\\n\\\`\\\`\\\`suggestion\\nuse std::collections::{HashMap, HashSet};\\n\\\`\\\`\\\`"
            }
            \`\`\`

            ---

            ## Quality Checklist

            Before submitting, verify:
            - [ ] Every comment has a severity label
            - [ ] Nits include suggestion blocks (or are omitted)
            - [ ] No comments on untouched lines
            - [ ] Suggestions match original indentation
            - [ ] Comment spans are ‚â§10 lines (\`line - start_line <= 10\`)
            - [ ] Summary includes issue counts and recommendation
            - [ ] JSON is valid, use \`jq\` to validate

            **Goal**:`;

            core.setOutput('review_prompt', prompt);

      - name: Run Oz Agent for PR Review
        uses: warpdotdev/oz-agent-action@v1
        id: oz
        with:
          prompt: ${{ steps.prompt.outputs.review_prompt }}
          warp_api_key: ${{ secrets.WARP_API_KEY }}
          share: team

      - name: Post Review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;

            // Read the review JSON
            let review;
            try {
              review = JSON.parse(fs.readFileSync('review.json', 'utf8'));
            } catch (e) {
              console.log('Failed to parse review.json:', e.message);
              return;
            }

            // Post inline comments
            if (review.comments && review.comments.length > 0) {
              const comments = review.comments.map(c => {
                const comment = {
                  path: c.path,
                  line: c.line,
                  side: c.side || 'RIGHT',
                  body: c.body,
                };
                if (c.start_line) {
                  comment.start_line = c.start_line;
                  comment.start_side = c.side || 'RIGHT';
                }
                return comment;
              });

              await github.rest.pulls.createReview({
                owner,
                repo,
                pull_number: prNumber,
                body: review.summary || 'Automated PR Review by Oz Agent',
                event: 'COMMENT',
                comments,
              });
            } else {
              // Post summary as a regular comment if no inline comments
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: review.summary || 'No issues found in this PR.',
              });
            }
